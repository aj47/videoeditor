<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <title>Video Block Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet">
    <script src="/assets/ffmpeg/package/dist/umd/ffmpeg.js"></script>
    <script src="/assets/util/package/dist/umd/index.js"></script>
</head>
<body>
    <div id="app">
        <div class="container mx-auto p-4">
            <!-- Header -->
            <div class="navbar bg-base-100 rounded-box shadow-lg mb-4">
                <div class="flex-1 flex items-center gap-2">
                    <h1 class="text-xl font-bold px-4">Video Block Editor</h1>
                    <input 
                        type="file" 
                        class="file-input file-input-bordered file-input-sm w-full max-w-xs"
                        accept="video/*"
                        @change="onFileSelect"
                    >
                </div>
                <div class="flex-none flex gap-2">
                    <button 
                        class="btn btn-sm" 
                        @click="saveState"
                        :disabled="!blocks.length"
                    >
                        Save State
                    </button>
                    <button 
                        class="btn btn-sm" 
                        @click="loadState"
                    >
                        Load State
                    </button>
                    <button class="btn btn-ghost" @click="showHelp">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Main Content -->
            <div class="grid grid-cols-1 gap-4">
                <!-- Video Player -->
                <div class="bg-base-200 rounded-box p-4">
                    <video 
                        ref="videoPlayer"
                        class="w-full aspect-video bg-black rounded-lg"
                        @timeupdate="onTimeUpdate"
                        @loadedmetadata="onVideoLoaded"
                        @durationchange="onDurationChange"
                    ></video>

                    <!-- Timeline -->
                    <div class="mt-4">
                        <canvas 
                            ref="timelineCanvas" 
                            class="w-full h-16 bg-base-300 rounded-lg"
                            @click="seekToPosition"
                        ></canvas>
                        <input 
                            type="range" 
                            class="range range-primary w-full mt-2" 
                            :min="0"
                            :max="duration"
                            :value="currentTime"
                            @input="seek"
                        >
                    </div>

                    <!-- Controls -->
                    <div class="flex flex-wrap gap-2 mt-4">
                        <div class="btn-group">
                            <button class="btn" @click="playPause">
                                {{ isPlaying ? 'Pause' : 'Play' }}
                            </button>
                            <button class="btn" @click="previousBlock" :disabled="!blocks.length">
                                Previous
                            </button>
                            <button class="btn" @click="nextBlock" :disabled="!blocks.length">
                                Next
                            </button>
                        </div>

                        <div class="btn-group">
                            <button 
                                class="btn btn-secondary"
                                @click="manageLabels"
                            >
                                Labels ({{ getCurrentBlockLabel }})
                            </button>
                            <button 
                                class="btn" 
                                :class="{ 'btn-accent': isOverwriteMode }"
                                @click="toggleMode"
                            >
                                {{ isOverwriteMode ? 'Overwrite' : 'Read' }}
                            </button>
                            <button class="btn" @click="resetBlocks" :disabled="!blocks.length">
                                Reset
                            </button>
                        </div>

                    </div>
                </div>

                <!-- Export Button -->
                <div class="bg-base-200 rounded-box p-4">
                    <div class="flex flex-wrap gap-2">
                        <button 
                            class="btn btn-primary" 
                            @click="exportVideo"
                            :disabled="!hasIncludedBlocks"
                        >
                            Export
                        </button>
                    </div>
                </div>

                <!-- Processing Overlay -->
                <div v-if="processing" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
                    <div class="bg-base-200 rounded-box p-8 max-w-md w-full mx-4">
                        <progress class="progress w-full" :value="progress" max="100"></progress>
                        <div class="text-center mt-4 text-lg font-semibold">{{ processingMessage }}</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Label Management Modal -->
        <dialog ref="labelModal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg">Manage Labels</h3>
                <div class="py-4">
                    <!-- Existing Labels -->
                    <div class="mb-4">
                        <h4 class="font-semibold mb-2">Existing Labels</h4>
                        <div v-for="(label, index) in labels" :key="index" class="flex items-center gap-2 mb-2">
                            <div class="w-4 h-4" :style="{ backgroundColor: label.color }"></div>
                            <span>{{ label.name }}</span>
                            <span class="ml-2 text-sm opacity-70">[{{ label.hotkey }}]</span>
                            <div class="flex gap-2 ml-auto">
                                <input 
                                    v-if="index > 1"
                                    type="text" 
                                    v-model="label.hotkey" 
                                    class="input input-xs input-bordered w-12"
                                    maxlength="1"
                                    @input="validateHotkey($event, index)"
                                >
                                <button 
                                    v-if="index > 1" 
                                    class="btn btn-xs btn-error" 
                                    @click="deleteLabel(index)"
                                >
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Add New Label -->
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">New Label Name</span>
                        </label>
                        <input 
                            type="text" 
                            v-model="newLabelName" 
                            class="input input-bordered w-full"
                            placeholder="Enter label name"
                        >
                    </div>
                    <div class="form-control mt-2">
                        <label class="label">
                            <span class="label-text">Color</span>
                        </label>
                        <input 
                            type="color" 
                            v-model="newLabelColor" 
                            class="w-full h-10"
                        >
                    </div>
                    <div class="form-control mt-2">
                        <label class="label">
                            <span class="label-text">Hotkey</span>
                        </label>
                        <input 
                            type="text"
                            v-model="newLabelHotkey"
                            class="input input-bordered"
                            maxlength="1"
                            placeholder="Single letter key"
                        >
                    </div>
                    <button 
                        class="btn btn-primary mt-4" 
                        @click="addLabel"
                        :disabled="!newLabelName"
                    >
                        Add Label
                    </button>
                </div>
                <div class="modal-action">
                    <form method="dialog">
                        <button class="btn">Close</button>
                    </form>
                </div>
            </div>
        </dialog>

        <!-- Help Modal -->
        <dialog ref="helpModal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg">Keyboard Shortcuts</h3>
                <div class="py-4">
                    <ul class="list-disc list-inside">
                        <li>Space: Play/Pause</li>
                        <li>Left Arrow: Previous Block</li>
                        <li>Right Arrow: Next Block</li>
                        <li>+: Zoom In</li>
                        <li>-: Zoom Out</li>
                    </ul>
                    <h4 class="font-bold mt-4 mb-2">Label Hotkeys:</h4>
                    <ul class="list-disc list-inside">
                        <template v-for="label in labels">
                            <li v-if="label.hotkey">
                                {{ label.hotkey }}: Apply "{{ label.name }}" label
                            </li>
                        </template>
                    </ul>
                </div>
                <div class="modal-action">
                    <form method="dialog">
                        <button class="btn">Close</button>
                    </form>
                </div>
            </div>
        </dialog>
    </div>

    <script>
        const { fetchFile, toBlobURL } = FFmpegUtil;
        const { FFmpeg } = FFmpegWASM;

        // Create FFmpeg instance
        const ffmpeg = new FFmpeg();

        new Vue({
            el: '#app',
            data() {
                return {
                    blocks: [],
                    currentTime: 0,
                    duration: 0,
                    isPlaying: false,
                    processing: false,
                    progress: 0,
                    processingMessage: '',
                    visibleBlocks: 200,
                    currentBlockIndex: 0,
                    skipTimer: null,
                    labels: [
                        { name: 'to-remove', color: 'red', hotkey: 'r' },
                        { name: 'misc', color: 'green', hotkey: 'm' }
                    ],
                    showLabelModal: false,
                    newLabelName: '',
                    newLabelColor: '#000000',
                    newLabelHotkey: '',
                    isOverwriteMode: false
                }
            },

            computed: {
                hasIncludedBlocks() {
                    return this.blocks.some(block => block.label !== 'to-remove');
                },
                getCurrentBlockLabel() {
                    if (this.currentBlockIndex === -1 || !this.blocks.length) return 'none';
                    const block = this.blocks[this.currentBlockIndex];
                    return block ? block.label : 'none';
                }
            },

            async mounted() {
                try {
                    const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
                    await ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm')
                    });
                    
                    ffmpeg.on('log', ({ message }) => {
                        console.log(message);
                    });
                    
                    ffmpeg.on('progress', ({ progress }) => {
                        this.progress = progress * 100;
                        this.processingMessage = `Processing: ${Math.round(progress * 100)}%`;
                    });

                } catch (error) {
                    console.error('Failed to load FFmpeg:', error);
                }

                // Set up keyboard shortcuts
                document.addEventListener('keydown', this.handleKeyPress);
            },

            beforeDestroy() {
                document.removeEventListener('keydown', this.handleKeyPress);
                if (this.skipTimer) {
                    clearInterval(this.skipTimer);
                }
            },

            methods: {
                handleKeyPress(e) {
                    // Don't handle keys if we're in an input field
                    if (e.target.tagName === 'INPUT') {
                        return;
                    }

                    switch(e.key) {
                        case 'Tab':
                            e.preventDefault();
                            this.toggleMode();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.playPause();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.previousBlock();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.nextBlock();
                            break;
                        case '+':
                            this.zoomIn();
                            break;
                        case '-':
                            this.zoomOut();
                            break;
                        default:
                            // Check for label hotkeys
                            const label = this.labels.find(l => l.hotkey === e.key.toLowerCase());
                            if (label && this.currentBlockIndex !== -1) {
                                const block = this.blocks[this.currentBlockIndex];
                                if (!block.isSilence && this.isOverwriteMode) {
                                    // Apply the label to all non-silence blocks
                                    this.blocks.forEach(b => {
                                        if (!b.isSilence) {
                                            b.label = label.name;
                                            b.color = label.color;
                                        }
                                    });
                                    this.drawTimeline(); // Redraw timeline immediately
                                }
                            }
                            break;
                    }
                },

                async onFileSelect(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const url = URL.createObjectURL(file);
                    this.$refs.videoPlayer.src = url;
                    
                    this.processing = true;
                    this.processingMessage = 'Processing video...';
                    
                    try {
                        await this.detectSilence(file);
                    } finally {
                        this.processing = false;
                    }
                },

                async detectSilence(file) {
                    const data = await file.arrayBuffer();
                    let silenceLog = '';
                    
                    // Set up log handler before processing
                    const logHandler = ({ message }) => {
                        if (message.includes('silencedetect')) {
                            silenceLog += message + '\n';
                        }
                    };
                    
                    ffmpeg.on('log', logHandler);
                    
                    try {
                        await ffmpeg.writeFile('input.mp4', new Uint8Array(data));
                        
                        await ffmpeg.exec([
                            '-i', 'input.mp4',
                            '-af', 'silencedetect=noise=-40dB:d=0.1',
                            '-f', 'null',
                            '-'
                        ]);
                        
                        this.blocks = this.parseSilenceDetection(silenceLog);
                    } finally {
                        // Clean up log handler
                        ffmpeg.off('log', logHandler);
                    }
                },

                parseSilenceDetection(output) {
                    const silenceStarts = [];
                    const silenceEnds = [];
                    const lines = output.split('\n');

                    lines.forEach(line => {
                        if (line.includes('silence_start')) {
                            const time = parseFloat(line.split('silence_start: ')[1]);
                            silenceStarts.push(time);
                        } else if (line.includes('silence_end')) {
                            const time = parseFloat(line.split('silence_end: ')[1]);
                            silenceEnds.push(time);
                        }
                    });

                    const blocks = [];
                    let currentTime = 0;

                    silenceStarts.forEach((start, i) => {
                        if (start > currentTime) {
                            blocks.push({
                                start: currentTime,
                                end: start,
                                isSilence: false,
                                visited: false,
                                label: 'misc',
                                color: 'green'
                            });
                        }
                        blocks.push({
                            start: start,
                            end: silenceEnds[i],
                            isSilence: true,
                            visited: false,
                            label: 'to-remove',
                            color: 'red'
                        });
                        currentTime = silenceEnds[i];
                    });

                    if (currentTime < this.duration) {
                        blocks.push({
                            start: currentTime,
                            end: this.duration,
                            isSilence: false,
                            visited: false,
                            label: 'misc',
                            color: 'green'
                        });
                    }

                    return blocks;
                },

                playPause() {
                    if (this.$refs.videoPlayer.paused) {
                        this.$refs.videoPlayer.play();
                        this.isPlaying = true;
                        this.skipTimer = setInterval(this.skipSilence, 100);
                    } else {
                        this.$refs.videoPlayer.pause();
                        this.isPlaying = false;
                        if (this.skipTimer) {
                            clearInterval(this.skipTimer);
                        }
                    }
                },

                skipSilence() {
                    if (!this.blocks.length) return;

                    const currentTime = this.$refs.videoPlayer.currentTime;
                    const currentBlock = this.blocks[this.currentBlockIndex];

                    if (!currentBlock) return;

                    if (currentBlock.isSilence || 
                        (!currentBlock.isSilence && currentBlock.end - currentBlock.start < 0.2)) {
                        const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex);
                        if (nextIndex !== null) {
                            this.currentBlockIndex = nextIndex;
                            const nextBlock = this.blocks[nextIndex];
                            this.$refs.videoPlayer.currentTime = nextBlock.start + 0.05;
                        } else {
                            this.$refs.videoPlayer.pause();
                            this.isPlaying = false;
                        }
                    }
                },

                findNextNonSilenceBlock(startIndex, forward = true) {
                    if (forward) {
                        for (let i = startIndex + 1; i < this.blocks.length; i++) {
                            if (!this.blocks[i].isSilence) {
                                return i;
                            }
                        }
                    } else {
                        for (let i = startIndex - 1; i >= 0; i--) {
                            if (!this.blocks[i].isSilence) {
                                return i;
                            }
                        }
                    }
                    return null;
                },

                previousBlock() {
                    const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex, false);
                    if (nextIndex !== null) {
                        const wasPlaying = !this.$refs.videoPlayer.paused;
                        this.currentBlockIndex = nextIndex;
                        this.$refs.videoPlayer.currentTime = this.blocks[nextIndex].start;
                        if (wasPlaying) {
                            this.$refs.videoPlayer.play();
                        }
                    }
                },

                nextBlock() {
                    const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex, true);
                    if (nextIndex !== null) {
                        const wasPlaying = !this.$refs.videoPlayer.paused;
                        this.currentBlockIndex = nextIndex;
                        this.$refs.videoPlayer.currentTime = this.blocks[nextIndex].start;
                        if (wasPlaying) {
                            this.$refs.videoPlayer.play();
                        }
                    }
                },


                resetBlocks() {
                    this.blocks.forEach(block => {
                        block.visited = false;
                        if (block.isSilence) {
                            block.label = 'to-remove';
                            block.color = 'red';
                        } else {
                            block.label = 'misc';
                            block.color = 'green';
                        }
                    });
                },

                zoomIn() {
                    this.visibleBlocks = Math.max(1, this.visibleBlocks - 1);
                },

                zoomOut() {
                    this.visibleBlocks = Math.min(this.blocks.length, this.visibleBlocks + 1);
                },

                onTimeUpdate() {
                    this.currentTime = this.$refs.videoPlayer.currentTime;
                    this.updateCurrentBlock();
                    this.drawTimeline();
                },

                onVideoLoaded() {
                    this.duration = this.$refs.videoPlayer.duration;
                },

                onDurationChange() {
                    this.duration = this.$refs.videoPlayer.duration;
                },

                updateCurrentBlock() {
                    const time = this.currentTime;
                    const index = this.blocks.findIndex(block => 
                        block.start <= time && time <= block.end
                    );
                    
                    if (index !== -1) {
                        this.currentBlockIndex = index;
                        const block = this.blocks[index];
                        if (!block.isSilence) {
                            block.visited = true;
                            if (!block.label) {
                                block.label = 'misc';
                                block.color = 'green';
                            }
                        }
                    }
                },

                drawTimeline() {
                    const canvas = this.$refs.timelineCanvas;
                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;

                    ctx.clearRect(0, 0, width, height);

                    this.blocks.forEach(block => {
                        const x = (block.start / this.duration) * width;
                        const w = ((block.end - block.start) / this.duration) * width;
                        
                        if (block.color) {
                            ctx.fillStyle = block.color;
                        } else {
                            ctx.fillStyle = 'gray';
                        }
                        
                        ctx.fillRect(x, 0, w, height);
                    });

                    const playheadX = (this.currentTime / this.duration) * width;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(playheadX - 1, 0, 2, height);
                },

                seekToPosition(event) {
                    const canvas = this.$refs.timelineCanvas;
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const time = (x / canvas.width) * this.duration;
                    this.$refs.videoPlayer.currentTime = time;
                },

                seek(event) {
                    this.$refs.videoPlayer.currentTime = event.target.value;
                },

                showHelp() {
                    this.$refs.helpModal.showModal();
                },

                manageLabels() {
                    this.$refs.labelModal.showModal();
                },

                validateHotkey(event, index) {
                    const value = event.target.value.toLowerCase();
                    // Only allow single letters
                    if (!/^[a-z]$/.test(value)) {
                        this.labels[index].hotkey = '';
                        return;
                    }
                    // Check for duplicate hotkeys
                    const isDuplicate = this.labels.some((label, i) => 
                        i !== index && label.hotkey === value
                    );
                    if (isDuplicate) {
                        this.labels[index].hotkey = '';
                        alert('This hotkey is already in use');
                        return;
                    }
                    this.labels[index].hotkey = value;
                },

                addLabel() {
                    if (this.newLabelName && this.newLabelHotkey) {
                        // Check for duplicate hotkey
                        if (this.labels.some(label => label.hotkey === this.newLabelHotkey)) {
                            alert('This hotkey is already in use');
                            return;
                        }
                        this.labels.push({
                            name: this.newLabelName,
                            color: this.newLabelColor,
                            hotkey: this.newLabelHotkey.toLowerCase()
                        });
                        this.newLabelName = '';
                        this.newLabelColor = '#000000';
                        this.newLabelHotkey = '';
                    }
                },

                deleteLabel(index) {
                    // Don't allow deletion of default labels (first two)
                    if (index > 1) {
                        // Update blocks using this label to use 'misc'
                        const deletedLabel = this.labels[index];
                        this.blocks.forEach(block => {
                            if (block.label === deletedLabel.name) {
                                block.label = 'misc';
                                block.color = 'green';
                            }
                        });
                        this.labels.splice(index, 1);
                    }
                },

                toggleMode() {
                    this.isOverwriteMode = !this.isOverwriteMode;
                },

                async loadState() {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'JSON Files',
                            accept: {'application/json': ['.json']}
                        }]
                    });
                    
                    const file = await fileHandle.getFile();
                    const state = JSON.parse(await file.text());
                    
                    this.$refs.videoPlayer.src = state.videoPath;
                    
                    this.blocks = state.blocks.map(block => ({
                        start: block.start,
                        end: block.end,
                        isSilence: block.is_silence,
                        visited: block.visited,
                        include: block.include
                    }));
                },

                async saveState() {
                    if (!this.blocks.length) {
                        alert("No blocks to save!");
                        return;
                    }

                    const state = {
                        videoPath: this.$refs.videoPlayer.src,
                        blocks: this.blocks.map(block => ({
                            start: block.start,
                            end: block.end,
                            is_silence: block.isSilence,
                            visited: block.visited,
                            include: block.include
                        }))
                    };

                    const blob = new Blob([JSON.stringify(state)], { type: 'application/json' });
                    const handle = await window.showSaveFilePicker({
                        types: [{
                            description: 'JSON Files',
                            accept: {'application/json': ['.json']}
                        }]
                    });
                    
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                },

                async exportVideo() {
                    if (!this.blocks.some(block => block.label !== 'to-remove')) {
                        alert("No blocks selected for export!");
                        return;
                    }

                    this.processing = true;
                    this.processingMessage = "Preparing for export...";

                    try {
                        // Get all unique labels except 'to-remove'
                        const labels = [...new Set(this.blocks
                            .filter(block => block.label !== 'to-remove')
                            .map(block => block.label))];

                        const inputVideo = await fetchFile(this.$refs.videoPlayer.src);
                        await ffmpeg.writeFile('input.mp4', inputVideo);

                        // Process each label separately
                        for (let labelIndex = 0; labelIndex < labels.length; labelIndex++) {
                            const label = labels[labelIndex];
                            this.processingMessage = `Processing ${label} clips (${labelIndex + 1}/${labels.length})...`;

                            const labelBlocks = this.blocks.filter(block => block.label === label);
                            let segmentsList = '';

                            // Extract segments for this label
                            for (let i = 0; i < labelBlocks.length; i++) {
                                const block = labelBlocks[i];
                                const duration = Math.max(0.1, block.end - block.start);
                                
                                await ffmpeg.exec([
                                    '-ss', block.start.toFixed(3),
                                    '-t', duration.toFixed(3),
                                    '-i', 'input.mp4',
                                    '-c', 'copy',
                                    '-avoid_negative_ts', 'make_zero',
                                    `segment_${i}.mp4`
                                ]);
                                
                                segmentsList += `file segment_${i}.mp4\n`;
                            }

                            // Combine segments for this label
                            await ffmpeg.writeFile('segments.txt', segmentsList);
                            await ffmpeg.exec([
                                '-f', 'concat',
                                '-safe', '0',
                                '-i', 'segments.txt',
                                '-c', 'copy',
                                `output_${label}.mp4`
                            ]);

                            // Download the combined video for this label
                            const data = await ffmpeg.readFile(`output_${label}.mp4`);
                            const blob = new Blob([data], { type: 'video/mp4' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `exported_${label}.mp4`;
                            a.click();
                            URL.revokeObjectURL(url);

                            // Clean up segment files
                            for (let i = 0; i < labelBlocks.length; i++) {
                                await ffmpeg.deleteFile(`segment_${i}.mp4`);
                            }
                        }

                    } catch (error) {
                        console.error('Export error:', error);
                        alert('Error during export: ' + error.message);
                    } finally {
                        this.processing = false;
                        this.processingMessage = '';
                    }
                }
            }
        });
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>
</html>
