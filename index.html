<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <title>Video Block Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet">
    <script src="/assets/ffmpeg/package/dist/umd/ffmpeg.js"></script>
    <script src="/assets/util/package/dist/umd/index.js"></script>
</head>
<body>
    <div id="app">
        <div class="container mx-auto p-4">
            <!-- Header -->
            <div class="navbar bg-base-100 rounded-box shadow-lg mb-4">
                <div class="flex-1 flex items-center gap-2">
                    <h1 class="text-xl font-bold px-4">Video Block Editor</h1>
                    <input 
                        type="file" 
                        class="file-input file-input-bordered file-input-sm w-full max-w-xs"
                        accept="video/*"
                        @change="onFileSelect"
                    >
                </div>
                <div class="flex-none flex gap-2">
                    <button 
                        class="btn btn-sm" 
                        @click="saveState"
                        :disabled="!blocks.length"
                    >
                        Save State
                    </button>
                    <button 
                        class="btn btn-sm" 
                        @click="loadState($event)"
                    >
                        Load State
                    </button>
                    <button class="btn btn-ghost" @click="showHelp">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Main Content -->
            <div class="grid grid-cols-1 gap-4">
                <!-- Video Player -->
                <div class="bg-base-200 rounded-box p-4">
                    <video 
                        ref="videoPlayer"
                        class="w-full aspect-video bg-black rounded-lg"
                        @timeupdate="onTimeUpdate"
                        @loadedmetadata="onVideoLoaded"
                        @durationchange="onDurationChange"
                    ></video>

                    <!-- Playhead Slider -->
                    <div class="mt-4">
                        <input 
                            type="range" 
                            v-model.number="currentTime" 
                            :max="duration" 
                            step="0.01"
                            class="range range-xs w-full"
                        >
                    </div>

                    <!-- Timeline -->
                    <div class="mt-2 relative overflow-x-auto">
                        <div class="flex justify-between text-xs mb-1">
                            <span>{{ formatTime(0) }}</span>
                            <span>{{ formatTime(duration) }}</span>
                        </div>
                        <canvas 
                            ref="timelineCanvas" 
                            class="w-full h-24 bg-base-300 rounded-lg cursor-pointer"
                            @click="seekToPosition"
                            @wheel.prevent="handleTimelineScroll"
                            @mousemove="updateTimelineHover"
                        ></canvas>
                        <div 
                            v-if="hoverTime !== null" 
                            class="absolute bg-base-100 px-2 py-1 rounded text-xs"
                            :style="{ left: hoverTimePosition + 'px', top: '-20px' }"
                        >
                            {{ formatTime(hoverTime) }}
                        </div>
                    </div>

                    <!-- Controls -->
                    <div class="flex flex-wrap gap-2 mt-4">
                        <div class="btn-group">
                            <button class="btn" @click="playPause">
                                {{ isPlaying ? 'Pause' : 'Play' }}
                            </button>
                            <button class="btn" @click="previousBlock" :disabled="!blocks.length">
                                Previous
                            </button>
                            <button class="btn" @click="nextBlock" :disabled="!blocks.length">
                                Next
                            </button>
                        </div>

                        <div class="btn-group">
                            <button 
                                class="btn btn-secondary"
                                @click="manageLabels"
                            >
                                Labels ({{ getCurrentBlockLabel }})
                            </button>
                            <button 
                                class="btn" 
                                :class="{ 'btn-accent': isOverwriteMode }"
                                @click="toggleMode"
                            >
                                {{ isOverwriteMode ? 'Overwrite' : 'Read' }}
                            </button>
                            <button class="btn" @click="resetBlocks" :disabled="!blocks.length">
                                Reset
                            </button>
                        </div>

                    </div>
                </div>

                <!-- Export Button -->
                <div class="bg-base-200 rounded-box p-4">
                    <div class="flex flex-wrap gap-2">
                        <button 
                            class="btn btn-primary" 
                            @click="exportVideo"
                            :disabled="!hasIncludedBlocks"
                        >
                            Export
                        </button>
                    </div>
                </div>

                <!-- Processing Overlay -->
                <div v-if="processing" class="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
                    <div class="bg-base-200 rounded-box p-8 max-w-md w-full mx-4">
                        <progress class="progress w-full" :value="progress" max="100"></progress>
                        <div class="text-center mt-4 text-lg font-semibold">{{ processingMessage }}</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Label Management Modal -->
        <dialog ref="labelModal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg">Manage Labels</h3>
                <div class="py-4">
                    <!-- Existing Labels -->
                    <div class="mb-4">
                        <h4 class="font-semibold mb-2">Existing Labels</h4>
                        <div v-for="(label, index) in labels" :key="index" class="flex items-center gap-2 mb-2">
                            <div class="w-4 h-4" :style="{ backgroundColor: label.color }"></div>
                            <span>{{ label.name }}</span>
                            <span class="ml-2 text-sm opacity-70">[{{ label.hotkey }}]</span>
                            <div class="flex gap-2 ml-auto">
                                <input 
                                    v-if="index > 1"
                                    type="text" 
                                    v-model="label.hotkey" 
                                    class="input input-xs input-bordered w-12"
                                    maxlength="1"
                                    @input="validateHotkey($event, index)"
                                >
                                <button 
                                    v-if="index > 1" 
                                    class="btn btn-xs btn-error" 
                                    @click="deleteLabel(index)"
                                >
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Add New Label -->
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">New Label Name</span>
                        </label>
                        <input 
                            type="text" 
                            v-model="newLabelName" 
                            class="input input-bordered w-full"
                            placeholder="Enter label name"
                        >
                    </div>
                    <div class="form-control mt-2">
                        <label class="label">
                            <span class="label-text">Color</span>
                        </label>
                        <input 
                            type="color" 
                            v-model="newLabelColor" 
                            class="w-full h-10"
                        >
                    </div>
                    <div class="form-control mt-2">
                        <label class="label">
                            <span class="label-text">Hotkey</span>
                        </label>
                        <input 
                            type="text"
                            v-model="newLabelHotkey"
                            class="input input-bordered"
                            maxlength="1"
                            placeholder="Single letter key"
                        >
                    </div>
                    <button 
                        class="btn btn-primary mt-4" 
                        @click="addLabel"
                        :disabled="!newLabelName"
                    >
                        Add Label
                    </button>
                </div>
                <div class="modal-action">
                    <form method="dialog">
                        <button class="btn">Close</button>
                    </form>
                </div>
            </div>
        </dialog>

        <!-- Help Modal -->
        <dialog ref="helpModal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg">Keyboard Shortcuts</h3>
                <div class="py-4">
                    <ul class="list-disc list-inside">
                        <li>Space: Play/Pause</li>
                        <li>Left Arrow: Previous Block</li>
                        <li>Right Arrow: Next Block</li>
                        <li>+: Zoom In</li>
                        <li>-: Zoom Out</li>
                    </ul>
                    <h4 class="font-bold mt-4 mb-2">Label Hotkeys:</h4>
                    <ul class="list-disc list-inside">
                        <template v-for="label in labels">
                            <li v-if="label.hotkey">
                                {{ label.hotkey }}: Apply "{{ label.name }}" label
                            </li>
                        </template>
                    </ul>
                </div>
                <div class="modal-action">
                    <form method="dialog">
                        <button class="btn">Close</button>
                    </form>
                </div>
            </div>
        </dialog>
    </div>

    <script>
        const { fetchFile, toBlobURL } = FFmpegUtil;
        const { FFmpeg } = FFmpegWASM;

        // Create FFmpeg instance
        const ffmpeg = new FFmpeg();

        new Vue({
            el: '#app',
            data() {
                return {
                    blocks: [],
                    currentTime: 0,
                    duration: 0,
                    isPlaying: false,
                    processing: false,
                    progress: 0,
                    processingMessage: '',
                    timelineZoom: 1,
                    currentBlockIndex: 0,
                    skipTimer: null,
                    labels: [],
                    showLabelModal: false,
                    newLabelName: '',
                    newLabelColor: '#000000',
                    newLabelHotkey: '',
                    isOverwriteMode: true,
                    hoverTime: null,
                    hoverTimePosition: 0,
                    currentFileHandle: null
                }
            },

            computed: {
                hasIncludedBlocks() {
                    return this.blocks.some(block => block.label !== 'to-remove');
                },
                getCurrentBlockLabel() {
                    if (this.currentBlockIndex === -1 || !this.blocks.length) return 'none';
                    const block = this.blocks[this.currentBlockIndex];
                    return block ? block.label : 'none';
                }
            },

            async mounted() {
                // Initialize timeline
                this.$nextTick(() => {
                    this.initTimeline();
                });
                
                // Load saved labels or use defaults
                const savedLabels = localStorage.getItem('videoEditorLabels');
                if (savedLabels) {
                    this.labels = JSON.parse(savedLabels);
                } else {
                    this.labels = [
                        { name: 'to-remove', color: 'red', hotkey: 'r' },
                        { name: 'misc', color: 'green', hotkey: 'm' }
                    ];
                    this.saveLabels();
                }

                try {
                    const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
                    await ffmpeg.load({
                        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm')
                    });
                    
                    ffmpeg.on('log', ({ message }) => {
                        console.log(message);
                    });
                    
                    ffmpeg.on('progress', ({ progress }) => {
                        this.progress = progress * 100;
                        this.processingMessage = `Processing: ${Math.round(progress * 100)}%`;
                    });

                } catch (error) {
                    console.error('Failed to load FFmpeg:', error);
                }

                // Set up keyboard shortcuts
                document.addEventListener('keydown', this.handleKeyPress);
            },

            beforeDestroy() {
                document.removeEventListener('keydown', this.handleKeyPress);
                if (this.skipTimer) {
                    clearInterval(this.skipTimer);
                }
            },

            methods: {
                handleKeyPress(e) {
                    // Don't handle keys if we're in an input field
                    if (e.target.tagName === 'INPUT') {
                        return;
                    }

                    switch(e.key) {
                        case 'Tab':
                            e.preventDefault();
                            this.toggleMode();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.playPause();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.previousBlock();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.nextBlock();
                            break;
                        case '+':
                            this.zoomIn();
                            break;
                        case '-':
                            this.zoomOut();
                            break;
                        default:
                            // Check for label hotkeys
                            const label = this.labels.find(l => l.hotkey === e.key.toLowerCase());
                            if (label && this.currentBlockIndex !== -1) {
                                const block = this.blocks[this.currentBlockIndex];
                                if (!block.isSilence) {
                                    if (this.isOverwriteMode) {
                                        block.label = label.name;
                                        block.color = label.color;
                                        this.drawTimeline(); // Redraw timeline immediately
                                    } else {
                                        // In read mode, only update if block is visited
                                        if (block.visited) {
                                            block.label = label.name;
                                            block.color = label.color;
                                            this.drawTimeline();
                                        }
                                    }
                                }
                            }
                            break;
                    }
                },

                async onFileSelect(event) {
                    console.log('onFileSelect triggered', event);
                    let url;
                    try {
                        // Use the selected file from the input
                        const file = event.target.files[0];
                        if (!file) return;
                        
                        if (file.size > 2 * 1024 * 1024 * 1024) { // 2GB
                            throw new Error('File is too large for FFmpeg.wasm (max 2GB)');
                        }

                        // Create URL for video playback
                        url = URL.createObjectURL(file);
                        this.$refs.videoPlayer.src = url;
                        
                        this.processing = true;
                        this.processingMessage = 'Processing video...';

                        // Process the file
                        const arrayBuffer = await file.arrayBuffer();
                        await ffmpeg.writeFile('input.mp4', new Uint8Array(arrayBuffer));
                        await this.detectSilence('input.mp4');
                    } catch (error) {
                        console.error('File processing error:', error);
                        alert(error.message);
                    } finally {
                        this.processing = false;
                        if (url) {
                            URL.revokeObjectURL(url);
                        }
                    }
                },

                async detectSilence(inputFile = 'input.mp4') {
                    let silenceLog = '';
                    
                    // Set up log handler before processing
                    const logHandler = ({ message }) => {
                        if (message.includes('silencedetect')) {
                            silenceLog += message + '\n';
                        }
                    };
                    
                    ffmpeg.on('log', logHandler);
                    
                    try {
                        await ffmpeg.exec([
                            '-i', inputFile,
                            '-af', 'silencedetect=noise=-40dB:d=0.1',
                            '-f', 'null',
                            '-'
                        ]);
                        
                        this.blocks = this.parseSilenceDetection(silenceLog);
                    } finally {
                        // Clean up log handler
                        ffmpeg.off('log', logHandler);
                        // Remove focus from file input
                        if (event && event.target && event.target instanceof HTMLInputElement) {
                            event.target.blur();
                        }
                    }
                },

                parseSilenceDetection(output) {
                    const silenceStarts = [];
                    const silenceEnds = [];
                    const lines = output.split('\n');
                    const BUFFER = 0.5; // 500ms buffer
                    const MIN_BLOCK_DURATION = 0.25; // Minimum block duration

                    lines.forEach(line => {
                        if (line.includes('silence_start')) {
                            const time = parseFloat(line.split('silence_start: ')[1]);
                            silenceStarts.push(time);
                        } else if (line.includes('silence_end')) {
                            const time = parseFloat(line.split('silence_end: ')[1]);
                            silenceEnds.push(time);
                        }
                    });

                    const blocks = [];
                    let currentTime = 0;

                    silenceStarts.forEach((start, i) => {
                        // Add buffer to block boundaries
                        // Calculate initial block boundaries
                        const blockStart = Math.max(0, start - BUFFER);
                        let blockEnd = Math.min(this.duration, silenceEnds[i] + BUFFER);
                        
                        // Ensure minimum duration while preserving buffer zones
                        const minDuration = BUFFER * 2;
                        if (blockEnd - blockStart < minDuration) {
                            // Extend end time if possible, otherwise adjust start time
                            if (blockEnd + minDuration <= this.duration) {
                                blockEnd = blockEnd + minDuration;
                            } else if (blockStart - minDuration >= 0) {
                                blockStart = blockStart - minDuration;
                            }
                        }
                        
                        // Only create non-silence block if there's enough space
                        if (blockStart > currentTime) {
                            const nonSilenceBlock = {
                                start: currentTime,
                                end: blockStart,
                                isSilence: false,
                                visited: false,
                                label: 'misc',
                                color: 'green'
                            };
                            
                            // Only add if block is long enough
                            if (nonSilenceBlock.end - nonSilenceBlock.start >= MIN_BLOCK_DURATION) {
                                blocks.push(nonSilenceBlock);
                            }
                        }

                        // Add silence block
                        const silenceBlock = {
                            start: blockStart,
                            end: blockEnd,
                            isSilence: true,
                            visited: false,
                            label: 'to-remove',
                            color: 'red'
                        };
                        
                        // Only add if block is long enough
                        if (silenceBlock.end - silenceBlock.start >= MIN_BLOCK_DURATION) {
                            blocks.push(silenceBlock);
                        }
                        
                        currentTime = blockEnd;
                    });

                    // Add final block if needed
                    if (currentTime < this.duration) {
                        const finalBlock = {
                            start: currentTime,
                            end: this.duration,
                            isSilence: false,
                            visited: false,
                            label: 'misc',
                            color: 'green'
                        };
                        
                        // Only add if block is long enough
                        if (finalBlock.end - finalBlock.start >= MIN_BLOCK_DURATION) {
                            blocks.push(finalBlock);
                        }
                    }

                    return blocks;
                },

                playPause() {
                    if (this.$refs.videoPlayer.paused) {
                        this.$refs.videoPlayer.play();
                        this.isPlaying = true;
                        this.skipTimer = setInterval(this.skipSilence, 100);
                    } else {
                        this.$refs.videoPlayer.pause();
                        this.isPlaying = false;
                        if (this.skipTimer) {
                            clearInterval(this.skipTimer);
                        }
                    }
                },

                skipSilence() {
                    if (!this.blocks.length) return;

                    const currentTime = this.$refs.videoPlayer.currentTime;
                    const currentBlock = this.blocks[this.currentBlockIndex];

                    if (!currentBlock) return;

                    if (currentBlock.isSilence || 
                        (!currentBlock.isSilence && currentBlock.end - currentBlock.start < 0.2)) {
                        const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex);
                        if (nextIndex !== null) {
                            // Store the previous non-silence block's label and color
                            let labelToApply = 'misc';
                            let colorToApply = 'green';
                            
                            // Look backwards to find the last non-silence block's label
                            for (let i = this.currentBlockIndex; i >= 0; i--) {
                                const block = this.blocks[i];
                                if (!block.isSilence) {
                                    labelToApply = block.label;
                                    colorToApply = block.color;
                                    break;
                                }
                            }
                            
                            this.currentBlockIndex = nextIndex;
                            const nextBlock = this.blocks[nextIndex];
                            
                            // If in overwrite mode, apply the previous label to the next block
                            if (this.isOverwriteMode && !nextBlock.isSilence) {
                                nextBlock.label = labelToApply;
                                nextBlock.color = colorToApply;
                                this.drawTimeline(); // Redraw timeline immediately
                            }
                            
                            this.$refs.videoPlayer.currentTime = nextBlock.start + 0.05;
                        } else {
                            this.$refs.videoPlayer.pause();
                            this.isPlaying = false;
                        }
                    }
                },

                findNextNonSilenceBlock(startIndex, forward = true) {
                    if (forward) {
                        for (let i = startIndex + 1; i < this.blocks.length; i++) {
                            if (!this.blocks[i].isSilence) {
                                return i;
                            }
                        }
                    } else {
                        for (let i = startIndex - 1; i >= 0; i--) {
                            if (!this.blocks[i].isSilence) {
                                return i;
                            }
                        }
                    }
                    return null;
                },

                previousBlock() {
                    const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex, false);
                    if (nextIndex !== null) {
                        const wasPlaying = !this.$refs.videoPlayer.paused;
                        this.currentBlockIndex = nextIndex;
                        this.$refs.videoPlayer.currentTime = this.blocks[nextIndex].start;
                        if (wasPlaying) {
                            this.$refs.videoPlayer.play();
                        }
                    }
                },

                nextBlock() {
                    const nextIndex = this.findNextNonSilenceBlock(this.currentBlockIndex, true);
                    if (nextIndex !== null) {
                        const wasPlaying = !this.$refs.videoPlayer.paused;
                        this.currentBlockIndex = nextIndex;
                        this.$refs.videoPlayer.currentTime = this.blocks[nextIndex].start;
                        if (wasPlaying) {
                            this.$refs.videoPlayer.play();
                        }
                    }
                },


                resetBlocks() {
                    if (confirm('Are you sure you want to reset all blocks to "to-remove"?')) {
                        this.blocks.forEach(block => {
                            block.visited = false;
                            block.label = 'to-remove';
                            block.color = 'red';
                        });
                        this.drawTimeline(); // Immediately update the timeline
                    }
                },

                formatTime(seconds) {
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    const ms = Math.floor((seconds % 1) * 100);
                    return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
                },

                handleTimelineScroll(event) {
                    const canvas = this.$refs.timelineCanvas;
                    const scrollAmount = event.deltaY;
                    canvas.parentElement.scrollLeft += scrollAmount;
                },

                updateTimelineHover(event) {
                    const canvas = this.$refs.timelineCanvas;
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    this.hoverTime = (x / canvas.width) * this.duration;
                    this.hoverTimePosition = x;
                },

                zoomIn() {
                    const zoomFactor = 0.8;
                    this.timelineZoom = Math.min(10, this.timelineZoom / zoomFactor);
                    this.drawTimeline();
                },

                zoomOut() {
                    const zoomFactor = 0.8;
                    this.timelineZoom = Math.max(1, this.timelineZoom * zoomFactor);
                    this.drawTimeline();
                },

                onTimeUpdate() {
                    const videoTime = this.$refs.videoPlayer.currentTime;
                    this.currentTime = videoTime;
                    this.updateCurrentBlock();
                    this.drawTimeline();
                },

                onVideoLoaded() {
                    this.duration = this.$refs.videoPlayer.duration;
                },

                onDurationChange() {
                    this.duration = this.$refs.videoPlayer.duration;
                },

                updateCurrentBlock() {
                    const time = this.currentTime;
                    const index = this.blocks.findIndex(block => 
                        block.start <= time && time <= block.end
                    );
                    
                    if (index !== -1) {
                        this.currentBlockIndex = index;
                        const block = this.blocks[index];
                        if (!block.isSilence && !this.isOverwriteMode) {
                            block.visited = true;
                            if (!block.label) {
                                block.label = 'misc';
                                block.color = 'green';
                            }
                        }
                    }
                },

                initTimeline() {
                    const canvas = this.$refs.timelineCanvas;
                    // Create offscreen canvas for double buffering
                    this.offscreenCanvas = document.createElement('canvas');
                    this.offscreenCanvas.width = canvas.width;
                    this.offscreenCanvas.height = canvas.height;
                    
                    // Set up high-performance rendering
                    canvas.style.imageRendering = 'crisp-edges';
                    this.ctx = canvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true
                    });
                    this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
                        alpha: false
                    });
                    
                    // Start render loop
                    this.renderTimeline();
                },

                renderTimeline() {
                    requestAnimationFrame(this.renderTimeline);
                    if (!this.shouldRedraw) return;
                    this.shouldRedraw = false;
                    
                    const width = this.offscreenCanvas.width;
                    const height = this.offscreenCanvas.height;
                    const ctx = this.offscreenCtx;
                    
                    // Clear with background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, width, height);
                    
                    const visibleDuration = this.duration;
                    const startTime = 0;
                    const endTime = this.duration;
                    
                    // Batch similar operations for better performance
                    ctx.save();
                    
                    // Draw all block backgrounds first
                    this.blocks.forEach(block => {
                        if (block.end < startTime || block.start > endTime) return;
                        const x = ((block.start - startTime) / visibleDuration) * width * this.timelineZoom;
                        const w = Math.max(1, ((block.end - block.start) / visibleDuration) * width * this.timelineZoom);
                    
                        ctx.fillStyle = block.color || 'gray';
                        ctx.fillRect(x, 0, w, height - 20);
                    });
                    
                    // Draw time markers with crisp lines
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    const markerInterval = Math.max(1, Math.floor(visibleDuration / 10));
                    
                    for (let t = Math.floor(startTime); t <= endTime; t += markerInterval) {
                        const x = Math.floor(((t - startTime) / visibleDuration) * width) + 0.5;
                        ctx.moveTo(x, height - 15);
                        ctx.lineTo(x, height);
                    }
                    ctx.stroke();
                    
                    // Draw time labels
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    for (let t = Math.floor(startTime); t <= endTime; t += markerInterval) {
                        const x = ((t - startTime) / visibleDuration) * width;
                        ctx.fillText(this.formatTime(t), x, height - 5);
                    }
                    
                    // Draw block labels efficiently
                    ctx.font = 'bold 12px sans-serif';
                    this.blocks.forEach(block => {
                        if (block.end < startTime || block.start > endTime) return;
                        const x = ((block.start - startTime) / visibleDuration) * width * this.timelineZoom;
                        const w = ((block.end - block.start) / visibleDuration) * width * this.timelineZoom;
                        
                        if (w > 50) {
                            ctx.fillText(block.label, x + 5, height - 30);
                        }
                    });
                    
                    // Draw playhead with anti-aliasing
                    const playheadX = Math.floor(((this.currentTime - startTime) / visibleDuration) * width * this.timelineZoom) + 0.5;
                    
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(playheadX - 8, height - 15);
                    ctx.lineTo(playheadX + 8, height - 15);
                    ctx.lineTo(playheadX, height);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Swap buffers
                    this.ctx.drawImage(this.offscreenCanvas, 0, 0);
                },

                drawTimeline() {
                    this.shouldRedraw = true;
                },

                seekToPosition(event) {
                    const canvas = this.$refs.timelineCanvas;
                    const rect = canvas.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const time = (x / canvas.width) * this.duration;
                    this.$refs.videoPlayer.currentTime = time;
                },

                seek(event) {
                    this.$refs.videoPlayer.currentTime = event.target.value;
                },

                showHelp() {
                    this.$refs.helpModal.showModal();
                },

                manageLabels() {
                    this.$refs.labelModal.showModal();
                },

                validateHotkey(event, index) {
                    const value = event.target.value.toLowerCase();
                    // Only allow single letters
                    if (!/^[a-z]$/.test(value)) {
                        this.labels[index].hotkey = '';
                        return;
                    }
                    // Check for duplicate hotkeys
                    const isDuplicate = this.labels.some((label, i) => 
                        i !== index && label.hotkey === value
                    );
                    if (isDuplicate) {
                        this.labels[index].hotkey = '';
                        alert('This hotkey is already in use');
                        return;
                    }
                    this.labels[index].hotkey = value;
                },

                saveLabels() {
                    localStorage.setItem('videoEditorLabels', JSON.stringify(this.labels));
                },

                addLabel() {
                    if (this.newLabelName && this.newLabelHotkey) {
                        // Check for duplicate hotkey
                        if (this.labels.some(label => label.hotkey === this.newLabelHotkey)) {
                            alert('This hotkey is already in use');
                            return;
                        }
                        this.labels.push({
                            name: this.newLabelName,
                            color: this.newLabelColor,
                            hotkey: this.newLabelHotkey.toLowerCase()
                        });
                        this.newLabelName = '';
                        this.newLabelColor = '#000000';
                        this.newLabelHotkey = '';
                        this.saveLabels();
                    }
                },

                deleteLabel(index) {
                    // Don't allow deletion of default labels (first two)
                    if (index > 1) {
                        // Update blocks using this label to use 'misc'
                        const deletedLabel = this.labels[index];
                        this.blocks.forEach(block => {
                            if (block.label === deletedLabel.name) {
                                block.label = 'misc';
                                block.color = 'green';
                            }
                        });
                        this.labels.splice(index, 1);
                        this.saveLabels();
                    }
                },

                toggleMode() {
                    this.isOverwriteMode = !this.isOverwriteMode;
                },

                async loadState(event) {
                    // Ensure this is triggered by a user action
                    if (!event || !event.isTrusted) {
                        console.error('Load state must be triggered by a user action');
                        return;
                    }
                    
                    try {
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: 'JSON Files',
                                accept: {'application/json': ['.json']}
                            }]
                        });
                        
                        // Verify we can read the file
                        if ((await fileHandle.queryPermission({ mode: 'read' })) !== 'granted') {
                            const newPermission = await fileHandle.requestPermission({ mode: 'read' });
                            if (newPermission !== 'granted') {
                                throw new Error('Permission to read file was denied');
                            }
                        }
                        
                        // Get a fresh file handle and read it immediately
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        const state = JSON.parse(text);
                        
                        // Validate state structure
                        if (!state.videoPath || !Array.isArray(state.blocks)) {
                            throw new Error('Invalid state file format');
                        }
                        
                        this.$refs.videoPlayer.src = state.videoPath;
                        
                        this.blocks = state.blocks.map(block => ({
                            start: block.start,
                            end: block.end,
                            isSilence: block.isSilence,
                            visited: block.visited,
                            label: block.label || (block.isSilence ? 'to-remove' : 'misc'),
                            color: block.color || (block.isSilence ? 'red' : 'green')
                        }));

                        // Load custom labels if present
                        if (Array.isArray(state.labels)) {
                            // Keep default labels
                            const defaultLabels = this.labels.slice(0, 2);
                            this.labels = [
                                ...defaultLabels,
                                ...state.labels.filter(label => 
                                    !defaultLabels.some(def => def.name === label.name)
                                )
                            ];
                        }

                        this.drawTimeline();
                    } catch (error) {
                        console.error('Error loading state:', error);
                        alert('Failed to load state: ' + error.message);
                    }
                },

                async saveState() {
                    if (!this.blocks.length) {
                        alert("No blocks to save!");
                        return;
                    }

                    try {
                        const state = {
                            videoPath: this.$refs.videoPlayer.src,
                            blocks: this.blocks.map(block => ({
                                start: block.start,
                                end: block.end,
                                isSilence: block.isSilence,
                                visited: block.visited,
                                label: block.label,
                                color: block.color
                            })),
                            // Save custom labels (excluding defaults)
                            labels: this.labels.slice(2)
                        };

                        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
                        const handle = await window.showSaveFilePicker({
                            types: [{
                                description: 'JSON Files',
                                accept: {'application/json': ['.json']}
                            }],
                            suggestedName: 'video-blocks.json'
                        });
                        
                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                    } catch (error) {
                        console.error('Error saving state:', error);
                        alert('Failed to save state: ' + error.message);
                    }
                },

                async exportVideo() {
                    if (!this.blocks.some(block => block.label !== 'to-remove')) {
                        alert("No blocks selected for export!");
                        return;
                    }

                    this.processing = true;
                    this.processingMessage = "Preparing for export...";

                    try {
                        // Get all unique labels except 'to-remove'
                        const labels = [...new Set(this.blocks
                            .filter(block => block.label !== 'to-remove')
                            .map(block => block.label))];

                        const inputVideo = await fetchFile(this.$refs.videoPlayer.src);
                        await ffmpeg.writeFile('input.mp4', inputVideo);

                        // Process each label separately
                        for (let labelIndex = 0; labelIndex < labels.length; labelIndex++) {
                            const label = labels[labelIndex];
                            this.processingMessage = `Processing ${label} clips (${labelIndex + 1}/${labels.length})...`;

                            // Group consecutive blocks with the same label
                            const labelBlocks = this.blocks.reduce((groups, block) => {
                                if (block.label !== label) return groups;
                                
                                const lastGroup = groups[groups.length - 1];
                                if (lastGroup && Math.abs(block.start - lastGroup.end) < 0.1) {
                                    // Merge with previous group if they're close enough
                                    lastGroup.end = block.end;
                                } else {
                                    // Start new group
                                    groups.push({
                                        start: block.start,
                                        end: block.end
                                    });
                                }
                                return groups;
                            }, []);

                            // Extract and combine segments for this label
                            for (let i = 0; i < labelBlocks.length; i++) {
                                const block = labelBlocks[i];
                                const duration = Math.max(0.1, block.end - block.start);
                                
                                this.processingMessage = `Processing ${label} segment ${i + 1}/${labelBlocks.length}...`;
                                
                                // Extract segment with proper encoding settings
                                await ffmpeg.exec([
                                    '-ss', block.start.toFixed(3),
                                    '-t', duration.toFixed(3),
                                    '-i', 'input.mp4',
                                    '-c:v', 'libx264',  // Use H.264 codec
                                    '-preset', 'medium', // Balance between speed and quality
                                    '-crf', '23',       // Constant Rate Factor for quality
                                    '-c:a', 'aac',      // Use AAC audio codec
                                    '-b:a', '128k',     // Audio bitrate
                                    '-movflags', '+faststart', // Enable fast start for web playback
                                    `segment_${i}.mp4`
                                ]);
                            }

                            if (labelBlocks.length > 0) {
                                // Create concat file
                                const segmentsList = labelBlocks.map((_, i) => 
                                    `file segment_${i}.mp4`
                                ).join('\n');
                                
                                await ffmpeg.writeFile('segments.txt', segmentsList);

                                // Combine segments with proper encoding
                                await ffmpeg.exec([
                                    '-f', 'concat',
                                    '-safe', '0',
                                    '-i', 'segments.txt',
                                    '-c', 'copy',  // Copy streams without re-encoding
                                    `output_${label}.mp4`
                                ]);

                                // Download the combined video
                                const data = await ffmpeg.readFile(`output_${label}.mp4`);
                                const blob = new Blob([data], { type: 'video/mp4' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `exported_${label}.mp4`;
                                a.style.display = 'none';
                                document.body.appendChild(a);
                                
                                // Use setTimeout to ensure the download starts before revoking
                                setTimeout(() => {
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(url);
                                }, 100);

                                // Clean up
                                for (let i = 0; i < labelBlocks.length; i++) {
                                    await ffmpeg.deleteFile(`segment_${i}.mp4`);
                                }
                                await ffmpeg.deleteFile('segments.txt');
                                await ffmpeg.deleteFile(`output_${label}.mp4`);
                            }
                        }

                    } catch (error) {
                        console.error('Export error:', error);
                        alert('Error during export: ' + error.message);
                    } finally {
                        this.processing = false;
                        this.processingMessage = '';
                        await ffmpeg.deleteFile('input.mp4');
                    }
                }
            }
        });
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</body>
</html>
